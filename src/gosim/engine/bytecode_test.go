package engine

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseGoldenWarGenome(t *testing.T) {
	// Load golden bytecode generated by Python
	goldenPath := filepath.Join("..", "..", "..", "tests", "golden", "war_genome.bin")
	bytecode, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Parse genome
	genome, err := ParseGenome(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse genome: %v", err)
	}

	// Verify header
	if genome.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", genome.Header.Version)
	}

	if genome.Header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", genome.Header.PlayerCount)
	}

	if genome.Header.MaxTurns != 1000 {
		t.Errorf("Expected 1000 max turns, got %d", genome.Header.MaxTurns)
	}

	// Verify turn structure
	if len(genome.TurnPhases) == 0 {
		t.Error("Expected at least one turn phase")
	}

	// War should have a play phase (players play from pre-dealt hands)
	foundPlayPhase := false
	for _, phase := range genome.TurnPhases {
		if phase.PhaseType == 2 { // PlayPhase
			foundPlayPhase = true
			break
		}
	}

	if !foundPlayPhase {
		t.Error("War genome should have a play phase")
	}

	// Verify win conditions
	if len(genome.WinConditions) == 0 {
		t.Error("Expected at least one win condition")
	}

	// War uses empty_hand (0) or capture_all (3)
	validWinType := false
	for _, wc := range genome.WinConditions {
		if wc.WinType == 0 || wc.WinType == 3 {
			validWinType = true
			break
		}
	}

	if !validWinType {
		t.Error("War should use empty_hand (0) or capture_all (3) win condition")
	}
}

func TestParseBytecodeHeader(t *testing.T) {
	// Minimal valid header (36 bytes)
	bytecode := make([]byte, 36)
	// Version (4 bytes) = 1
	bytecode[3] = 1
	// GenomeIDHash (8 bytes) = 0
	// PlayerCount (4 bytes) = 2
	bytecode[15] = 2
	// MaxTurns (4 bytes) = 100
	bytecode[19] = 100
	// Offsets all at 36
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 36 // turn_structure_offset
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	header, err := ParseHeader(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse header: %v", err)
	}

	if header.Version != 1 {
		t.Errorf("Expected version 1, got %d", header.Version)
	}

	if header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", header.PlayerCount)
	}

	if header.MaxTurns != 100 {
		t.Errorf("Expected 100 max turns, got %d", header.MaxTurns)
	}
}

func TestParseBytecodeHeaderTooShort(t *testing.T) {
	bytecode := make([]byte, 20) // Too short
	_, err := ParseHeader(bytecode)
	if err == nil {
		t.Error("Expected error for short bytecode")
	}
}

func TestParseInvalidOffsets(t *testing.T) {
	// Create bytecode with invalid turn structure offset
	bytecode := make([]byte, 100)
	// Set header fields
	bytecode[3] = 1   // version
	bytecode[15] = 2  // player_count
	bytecode[19] = 50 // max_turns
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 200 // turn_structure_offset (beyond bytecode length!)
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	_, err := ParseGenome(bytecode)
	if err == nil {
		t.Error("Expected error for invalid offset")
	}
}

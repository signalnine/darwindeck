package engine

import (
	"os"
	"path/filepath"
	"testing"
)

func TestParseGoldenWarGenome(t *testing.T) {
	// Load golden bytecode generated by Python
	goldenPath := filepath.Join("..", "..", "..", "tests", "golden", "war_genome.bin")
	bytecode, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Parse genome
	genome, err := ParseGenome(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse genome: %v", err)
	}

	// Verify header
	if genome.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", genome.Header.Version)
	}

	if genome.Header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", genome.Header.PlayerCount)
	}

	if genome.Header.MaxTurns != 1000 {
		t.Errorf("Expected 1000 max turns, got %d", genome.Header.MaxTurns)
	}

	// Verify turn structure
	if len(genome.TurnPhases) == 0 {
		t.Error("Expected at least one turn phase")
	}

	// War should have a play phase (players play from pre-dealt hands)
	foundPlayPhase := false
	for _, phase := range genome.TurnPhases {
		if phase.PhaseType == 2 { // PlayPhase
			foundPlayPhase = true
			break
		}
	}

	if !foundPlayPhase {
		t.Error("War genome should have a play phase")
	}

	// Verify win conditions
	if len(genome.WinConditions) == 0 {
		t.Error("Expected at least one win condition")
	}

	// War uses empty_hand (0) or capture_all (3)
	validWinType := false
	for _, wc := range genome.WinConditions {
		if wc.WinType == 0 || wc.WinType == 3 {
			validWinType = true
			break
		}
	}

	if !validWinType {
		t.Error("War should use empty_hand (0) or capture_all (3) win condition")
	}
}

func TestParseBytecodeHeader(t *testing.T) {
	// Minimal valid header (36 bytes)
	bytecode := make([]byte, 36)
	// Version (4 bytes) = 1
	bytecode[3] = 1
	// GenomeIDHash (8 bytes) = 0
	// PlayerCount (4 bytes) = 2
	bytecode[15] = 2
	// MaxTurns (4 bytes) = 100
	bytecode[19] = 100
	// Offsets all at 36
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 36 // turn_structure_offset
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	header, err := ParseHeader(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse header: %v", err)
	}

	if header.Version != 1 {
		t.Errorf("Expected version 1, got %d", header.Version)
	}

	if header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", header.PlayerCount)
	}

	if header.MaxTurns != 100 {
		t.Errorf("Expected 100 max turns, got %d", header.MaxTurns)
	}
}

func TestParseBytecodeHeaderTooShort(t *testing.T) {
	bytecode := make([]byte, 20) // Too short
	_, err := ParseHeader(bytecode)
	if err == nil {
		t.Error("Expected error for short bytecode")
	}
}

func TestParseInvalidOffsets(t *testing.T) {
	// Create bytecode with invalid turn structure offset
	bytecode := make([]byte, 100)
	// Set header fields
	bytecode[3] = 1   // version
	bytecode[15] = 2  // player_count
	bytecode[19] = 50 // max_turns
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 200 // turn_structure_offset (beyond bytecode length!)
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	_, err := ParseGenome(bytecode)
	if err == nil {
		t.Error("Expected error for invalid offset")
	}
}

func TestParseEffects(t *testing.T) {
	// Bytecode: HEADER(60), count(2), effect1(4 bytes), effect2(4 bytes)
	data := []byte{
		60, 2,          // Header, count=2
		0, 2, 0, 2,     // TWO, DRAW_CARDS, NEXT_PLAYER, value=2
		9, 0, 0, 1,     // JACK, SKIP_NEXT, NEXT_PLAYER, value=1
	}

	effects, offset, err := parseEffects(data, 0)
	if err != nil {
		t.Fatalf("parseEffects failed: %v", err)
	}

	if offset != 10 {
		t.Errorf("offset should be 10, got %d", offset)
	}

	if len(effects) != 2 {
		t.Fatalf("should have 2 effects, got %d", len(effects))
	}

	// Check effect for rank 0 (TWO)
	e1, ok := effects[0]
	if !ok {
		t.Fatal("missing effect for rank 0")
	}
	if e1.EffectType != EFFECT_DRAW_CARDS || e1.Value != 2 {
		t.Errorf("effect 1: expected DRAW_CARDS/2, got %d/%d", e1.EffectType, e1.Value)
	}

	// Check effect for rank 9 (JACK)
	e2, ok := effects[9]
	if !ok {
		t.Fatal("missing effect for rank 9")
	}
	if e2.EffectType != EFFECT_SKIP_NEXT || e2.Value != 1 {
		t.Errorf("effect 2: expected SKIP_NEXT/1, got %d/%d", e2.EffectType, e2.Value)
	}
}

func TestParseEffectsBoundsCheck(t *testing.T) {
	// Truncated bytecode - says 2 effects but only has 1
	data := []byte{
		60, 2,          // Header, count=2
		0, 2, 0, 2,     // Only 1 effect
	}

	_, _, err := parseEffects(data, 0)
	if err == nil {
		t.Error("should fail on truncated data")
	}
}

func TestParseEffectsEmpty(t *testing.T) {
	// No effects section - different opcode
	data := []byte{99, 0, 0}

	effects, offset, err := parseEffects(data, 0)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if offset != 0 {
		t.Errorf("offset should be 0 (no effects), got %d", offset)
	}
	if len(effects) != 0 {
		t.Errorf("should have 0 effects, got %d", len(effects))
	}
}

package engine

import (
	"os"
	"path/filepath"
	"reflect"
	"testing"
)

func TestParseGoldenWarGenome(t *testing.T) {
	// Load golden bytecode generated by Python
	goldenPath := filepath.Join("..", "..", "..", "tests", "golden", "war_genome.bin")
	bytecode, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Parse genome
	genome, err := ParseGenome(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse genome: %v", err)
	}

	// Verify header
	if genome.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", genome.Header.Version)
	}

	if genome.Header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", genome.Header.PlayerCount)
	}

	if genome.Header.MaxTurns != 1000 {
		t.Errorf("Expected 1000 max turns, got %d", genome.Header.MaxTurns)
	}

	// Verify turn structure
	if len(genome.TurnPhases) == 0 {
		t.Error("Expected at least one turn phase")
	}

	// War should have a play phase (players play from pre-dealt hands)
	foundPlayPhase := false
	for _, phase := range genome.TurnPhases {
		if phase.PhaseType == 2 { // PlayPhase
			foundPlayPhase = true
			break
		}
	}

	if !foundPlayPhase {
		t.Error("War genome should have a play phase")
	}

	// Verify win conditions
	if len(genome.WinConditions) == 0 {
		t.Error("Expected at least one win condition")
	}

	// War uses empty_hand (0) or capture_all (3)
	validWinType := false
	for _, wc := range genome.WinConditions {
		if wc.WinType == 0 || wc.WinType == 3 {
			validWinType = true
			break
		}
	}

	if !validWinType {
		t.Error("War should use empty_hand (0) or capture_all (3) win condition")
	}
}

func TestParseBytecodeHeader(t *testing.T) {
	// Minimal valid header (36 bytes)
	bytecode := make([]byte, 36)
	// Version (4 bytes) = 1
	bytecode[3] = 1
	// GenomeIDHash (8 bytes) = 0
	// PlayerCount (4 bytes) = 2
	bytecode[15] = 2
	// MaxTurns (4 bytes) = 100
	bytecode[19] = 100
	// Offsets all at 36
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 36 // turn_structure_offset
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	header, err := ParseHeader(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse header: %v", err)
	}

	if header.Version != 1 {
		t.Errorf("Expected version 1, got %d", header.Version)
	}

	if header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", header.PlayerCount)
	}

	if header.MaxTurns != 100 {
		t.Errorf("Expected 100 max turns, got %d", header.MaxTurns)
	}
}

func TestParseBytecodeHeaderTooShort(t *testing.T) {
	bytecode := make([]byte, 20) // Too short
	_, err := ParseHeader(bytecode)
	if err == nil {
		t.Error("Expected error for short bytecode")
	}
}

func TestParseInvalidOffsets(t *testing.T) {
	// Create bytecode with invalid turn structure offset
	bytecode := make([]byte, 100)
	// Set header fields
	bytecode[3] = 1   // version
	bytecode[15] = 2  // player_count
	bytecode[19] = 50 // max_turns
	bytecode[23] = 36 // setup_offset
	bytecode[27] = 200 // turn_structure_offset (beyond bytecode length!)
	bytecode[31] = 36 // win_conditions_offset
	bytecode[35] = 36 // scoring_offset

	_, err := ParseGenome(bytecode)
	if err == nil {
		t.Error("Expected error for invalid offset")
	}
}

func TestParseEffects(t *testing.T) {
	// Bytecode: HEADER(60), count(2), effect1(4 bytes), effect2(4 bytes)
	data := []byte{
		60, 2,          // Header, count=2
		0, 2, 0, 2,     // TWO, DRAW_CARDS, NEXT_PLAYER, value=2
		9, 0, 0, 1,     // JACK, SKIP_NEXT, NEXT_PLAYER, value=1
	}

	effects, offset, err := parseEffects(data, 0)
	if err != nil {
		t.Fatalf("parseEffects failed: %v", err)
	}

	if offset != 10 {
		t.Errorf("offset should be 10, got %d", offset)
	}

	if len(effects) != 2 {
		t.Fatalf("should have 2 effects, got %d", len(effects))
	}

	// Check effect for rank 0 (TWO)
	e1, ok := effects[0]
	if !ok {
		t.Fatal("missing effect for rank 0")
	}
	if e1.EffectType != EFFECT_DRAW_CARDS || e1.Value != 2 {
		t.Errorf("effect 1: expected DRAW_CARDS/2, got %d/%d", e1.EffectType, e1.Value)
	}

	// Check effect for rank 9 (JACK)
	e2, ok := effects[9]
	if !ok {
		t.Fatal("missing effect for rank 9")
	}
	if e2.EffectType != EFFECT_SKIP_NEXT || e2.Value != 1 {
		t.Errorf("effect 2: expected SKIP_NEXT/1, got %d/%d", e2.EffectType, e2.Value)
	}
}

func TestParseEffectsBoundsCheck(t *testing.T) {
	// Truncated bytecode - says 2 effects but only has 1
	data := []byte{
		60, 2,          // Header, count=2
		0, 2, 0, 2,     // Only 1 effect
	}

	_, _, err := parseEffects(data, 0)
	if err == nil {
		t.Error("should fail on truncated data")
	}
}

func TestParseEffectsEmpty(t *testing.T) {
	// No effects section - different opcode
	data := []byte{99, 0, 0}

	effects, offset, err := parseEffects(data, 0)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if offset != 0 {
		t.Errorf("offset should be 0 (no effects), got %d", offset)
	}
	if len(effects) != 0 {
		t.Errorf("should have 0 effects, got %d", len(effects))
	}
}

func TestParseBettingPhaseData(t *testing.T) {
	// Create betting phase data: min_bet=100, max_raises=3
	// Format: min_bet:4 + max_raises:4 = 8 bytes (matching Python bytecode.py)
	data := make([]byte, 8)
	// min_bet = 100 (big-endian)
	data[0] = 0
	data[1] = 0
	data[2] = 0
	data[3] = 100
	// max_raises = 3 (big-endian)
	data[4] = 0
	data[5] = 0
	data[6] = 0
	data[7] = 3

	betting, err := ParseBettingPhaseData(data)
	if err != nil {
		t.Fatalf("Failed to parse betting phase data: %v", err)
	}

	if betting.MinBet != 100 {
		t.Errorf("Expected MinBet=100, got %d", betting.MinBet)
	}

	if betting.MaxRaises != 3 {
		t.Errorf("Expected MaxRaises=3, got %d", betting.MaxRaises)
	}
}

func TestParseBettingPhaseDataTooShort(t *testing.T) {
	// Data too short (need at least 8 bytes)
	data := make([]byte, 4)
	_, err := ParseBettingPhaseData(data)
	if err == nil {
		t.Error("Expected error for short data")
	}
}

func TestParseGoldenSimplePokerGenome(t *testing.T) {
	// Load golden bytecode for simple_poker (betting genome) generated by Python
	goldenPath := filepath.Join("..", "..", "..", "tests", "golden", "simple_poker_genome.bin")
	bytecode, err := os.ReadFile(goldenPath)
	if err != nil {
		t.Fatalf("Failed to read golden file: %v", err)
	}

	// Parse genome - this is the critical test that would have caught the bug
	genome, err := ParseGenome(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse genome: %v", err)
	}

	// Verify header
	if genome.Header.Version != 1 {
		t.Errorf("Expected version 1, got %d", genome.Header.Version)
	}

	if genome.Header.PlayerCount != 2 {
		t.Errorf("Expected 2 players, got %d", genome.Header.PlayerCount)
	}

	// Verify turn structure has BettingPhase
	foundBettingPhase := false
	for _, phase := range genome.TurnPhases {
		if phase.PhaseType == PhaseTypeBetting {
			foundBettingPhase = true

			// Verify betting phase data can be parsed
			bettingData, err := ParseBettingPhaseData(phase.Data)
			if err != nil {
				t.Fatalf("Failed to parse betting phase data: %v", err)
			}

			// simple_poker uses min_bet=10, max_raises=3
			if bettingData.MinBet != 10 {
				t.Errorf("Expected MinBet=10, got %d", bettingData.MinBet)
			}
			if bettingData.MaxRaises != 3 {
				t.Errorf("Expected MaxRaises=3, got %d", bettingData.MaxRaises)
			}
			break
		}
	}

	if !foundBettingPhase {
		t.Error("simple_poker genome should have a BettingPhase")
	}
}

func TestPhaseTypeConstants(t *testing.T) {
	// Verify phase type constants match expected values
	if PhaseTypeDraw != 1 {
		t.Errorf("PhaseTypeDraw should be 1, got %d", PhaseTypeDraw)
	}
	if PhaseTypePlay != 2 {
		t.Errorf("PhaseTypePlay should be 2, got %d", PhaseTypePlay)
	}
	if PhaseTypeDiscard != 3 {
		t.Errorf("PhaseTypeDiscard should be 3, got %d", PhaseTypeDiscard)
	}
	if PhaseTypeTrick != 4 {
		t.Errorf("PhaseTypeTrick should be 4, got %d", PhaseTypeTrick)
	}
	if PhaseTypeBetting != 5 {
		t.Errorf("PhaseTypeBetting should be 5, got %d", PhaseTypeBetting)
	}
	if PhaseTypeClaim != 6 {
		t.Errorf("PhaseTypeClaim should be 6, got %d", PhaseTypeClaim)
	}
}

func TestParseCardScoringRules(t *testing.T) {
	// Hearts scoring: hearts=1pt, QS=13pt
	bytecode := []byte{
		0x00, 0x02, // 2 rules
		0x00, 0xFF, 0x00, 0x01, 0x00, // Hearts suit, any rank, 1 point, TRICK_WIN
		0x03, 0x0A, 0x00, 0x0D, 0x00, // Spades suit, Queen rank, 13 points, TRICK_WIN
	}

	rules, err := ParseCardScoringRules(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse: %v", err)
	}

	if len(rules) != 2 {
		t.Errorf("Expected 2 rules, got %d", len(rules))
	}

	// Check first rule (Hearts)
	if rules[0].Suit != 0 || rules[0].Points != 1 {
		t.Errorf("First rule wrong: suit=%d points=%d", rules[0].Suit, rules[0].Points)
	}
	if rules[0].Rank != 0xFF {
		t.Errorf("First rule rank wrong: expected 0xFF (any), got %d", rules[0].Rank)
	}
	if rules[0].Trigger != TriggerTrickWin {
		t.Errorf("First rule trigger wrong: expected %d, got %d", TriggerTrickWin, rules[0].Trigger)
	}

	// Check second rule (Queen of Spades)
	if rules[1].Suit != 3 || rules[1].Rank != 10 || rules[1].Points != 13 {
		t.Errorf("Second rule wrong: suit=%d rank=%d points=%d", rules[1].Suit, rules[1].Rank, rules[1].Points)
	}
	if rules[1].Trigger != TriggerTrickWin {
		t.Errorf("Second rule trigger wrong: expected %d, got %d", TriggerTrickWin, rules[1].Trigger)
	}
}

func TestParseCardScoringRulesEmpty(t *testing.T) {
	// Empty rules (count = 0)
	bytecode := []byte{0x00, 0x00}
	rules, err := ParseCardScoringRules(bytecode)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if rules != nil {
		t.Errorf("Expected nil rules for count=0, got %v", rules)
	}
}

func TestParseCardScoringRulesTooShort(t *testing.T) {
	// Data too short (need at least 2 bytes for count)
	bytecode := []byte{0x00}
	rules, err := ParseCardScoringRules(bytecode)
	if err != nil {
		t.Fatalf("Unexpected error for short data: %v", err)
	}
	if rules != nil {
		t.Errorf("Expected nil rules for short data, got %v", rules)
	}
}

func TestParseCardScoringRulesTruncated(t *testing.T) {
	// Says 2 rules but only has data for 1
	bytecode := []byte{
		0x00, 0x02, // 2 rules
		0x00, 0xFF, 0x00, 0x01, 0x00, // Only 1 complete rule
	}
	_, err := ParseCardScoringRules(bytecode)
	if err == nil {
		t.Error("Expected error for truncated data")
	}
}

func TestParseCardScoringRulesNegativePoints(t *testing.T) {
	// Test negative points (signed int16)
	// -5 in two's complement big-endian is 0xFF, 0xFB
	bytecode := []byte{
		0x00, 0x01, // 1 rule
		0x02, 0x05, 0xFF, 0xFB, 0x01, // Clubs suit, rank 5, -5 points, CAPTURE
	}

	rules, err := ParseCardScoringRules(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse: %v", err)
	}

	if len(rules) != 1 {
		t.Fatalf("Expected 1 rule, got %d", len(rules))
	}

	if rules[0].Points != -5 {
		t.Errorf("Expected points=-5, got %d", rules[0].Points)
	}
	if rules[0].Trigger != TriggerCapture {
		t.Errorf("Expected trigger=%d (CAPTURE), got %d", TriggerCapture, rules[0].Trigger)
	}
}

func TestParseHandEvaluation(t *testing.T) {
	// Blackjack: POINT_TOTAL, target=21, bust=22, Ace=1/11
	bytecode := []byte{
		0x02,             // POINT_TOTAL method
		0x15,             // target_value = 21
		0x16,             // bust_threshold = 22
		0x01,             // 1 card value
		0x0C, 0x01, 0x0B, // Ace (12), value=1, alt=11
		0x00,             // 0 patterns
	}

	eval, err := ParseHandEvaluation(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse: %v", err)
	}

	if eval.Method != EvalMethodPointTotal {
		t.Errorf("Expected POINT_TOTAL (2), got %d", eval.Method)
	}
	if eval.TargetValue != 21 {
		t.Errorf("Expected target 21, got %d", eval.TargetValue)
	}
	if eval.BustThreshold != 22 {
		t.Errorf("Expected bust 22, got %d", eval.BustThreshold)
	}
	if len(eval.CardValues) != 1 {
		t.Fatalf("Expected 1 card value, got %d", len(eval.CardValues))
	}

	// Check Ace card value
	ace := eval.CardValues[0]
	if ace.Rank != 12 {
		t.Errorf("Expected Ace rank (12), got %d", ace.Rank)
	}
	if ace.Value != 1 {
		t.Errorf("Expected Ace value 1, got %d", ace.Value)
	}
	if ace.AltValue != 11 {
		t.Errorf("Expected Ace alt value 11, got %d", ace.AltValue)
	}

	if len(eval.Patterns) != 0 {
		t.Errorf("Expected 0 patterns, got %d", len(eval.Patterns))
	}
}

func TestParseHandEvaluationNone(t *testing.T) {
	// Method NONE returns nil
	bytecode := []byte{0x00}

	eval, err := ParseHandEvaluation(bytecode)
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if eval != nil {
		t.Errorf("Expected nil for NONE method, got %+v", eval)
	}
}

func TestParseHandEvaluationEmpty(t *testing.T) {
	// Empty data returns nil
	eval, err := ParseHandEvaluation([]byte{})
	if err != nil {
		t.Fatalf("Unexpected error: %v", err)
	}
	if eval != nil {
		t.Errorf("Expected nil for empty data, got %+v", eval)
	}
}

func TestParseHandEvaluationWithPatterns(t *testing.T) {
	// Poker-style: PATTERN_MATCH with a simple pattern
	bytecode := []byte{
		0x03,       // PATTERN_MATCH method
		0x00,       // target_value = 0 (unused)
		0x00,       // bust_threshold = 0 (unused)
		0x00,       // 0 card values
		0x01,       // 1 pattern
		// Pattern: rank_priority=1, required_count=5, same_suit=5, seq_len=5, wrap=false
		0x01, 0x05, 0x05, 0x05, 0x00,
		0x00,       // 0 same rank groups
		0x00,       // 0 required ranks
	}

	eval, err := ParseHandEvaluation(bytecode)
	if err != nil {
		t.Fatalf("Failed to parse: %v", err)
	}

	if eval.Method != EvalMethodPatternMatch {
		t.Errorf("Expected PATTERN_MATCH (3), got %d", eval.Method)
	}
	if len(eval.Patterns) != 1 {
		t.Fatalf("Expected 1 pattern, got %d", len(eval.Patterns))
	}

	p := eval.Patterns[0]
	if p.RankPriority != 1 {
		t.Errorf("Expected rank priority 1, got %d", p.RankPriority)
	}
	if p.RequiredCount != 5 {
		t.Errorf("Expected required count 5, got %d", p.RequiredCount)
	}
	if p.SameSuitCount != 5 {
		t.Errorf("Expected same suit count 5, got %d", p.SameSuitCount)
	}
	if p.SequenceLength != 5 {
		t.Errorf("Expected sequence length 5, got %d", p.SequenceLength)
	}
	if p.SequenceWrap {
		t.Error("Expected sequence wrap false")
	}
}

func TestParseHandEvaluationTruncated(t *testing.T) {
	// Too short for a valid evaluation
	bytecode := []byte{0x02, 0x15} // Method + target, missing bust_threshold

	_, err := ParseHandEvaluation(bytecode)
	if err == nil {
		t.Error("Expected error for truncated data")
	}
}

func TestParseHandEvaluationTruncatedCardValues(t *testing.T) {
	// Says 2 card values but only has data for 1
	bytecode := []byte{
		0x02,             // POINT_TOTAL method
		0x15,             // target_value = 21
		0x16,             // bust_threshold = 22
		0x02,             // 2 card values (but only 1 follows)
		0x0C, 0x01, 0x0B, // Only 1 card value
	}

	_, err := ParseHandEvaluation(bytecode)
	if err == nil {
		t.Error("Expected error for truncated card values")
	}
}

func TestParseGenomeVersion2(t *testing.T) {
	// Minimal v2 bytecode: version byte + 36-byte struct + tableau fields
	// Total: 39 bytes minimum for header
	// Then we need turn structure and win conditions sections

	// Build a minimal v2 bytecode:
	// Byte 0: version = 2
	// Bytes 1-4: legacy version (uint32) = 1
	// Bytes 5-12: genome_id_hash (uint64) = 0
	// Bytes 13-16: player_count (uint32) = 2
	// Bytes 17-20: max_turns (uint32) = 100
	// Bytes 21-24: setup_offset (int32) = 39
	// Bytes 25-28: turn_structure_offset (int32) = 39
	// Bytes 29-32: win_conditions_offset (int32) = 43 (after turn structure)
	// Bytes 33-36: scoring_offset (int32) = 48 (after win conditions)
	// Byte 37: tableau_mode = 1 (WAR)
	// Byte 38: sequence_direction = 0 (ASCENDING)
	// Then turn structure: phase_count(4) = 0
	// Then win conditions: count(4) = 0

	bytecode := make([]byte, 48)
	bytecode[0] = 2  // Version 2

	// Legacy version = 1 (big-endian)
	bytecode[4] = 1

	// Player count = 2 (big-endian at bytes 13-16, which is offset 13)
	bytecode[16] = 2

	// Max turns = 100 (big-endian at bytes 17-20)
	bytecode[20] = 100

	// Setup offset = 39 (big-endian at bytes 21-24)
	bytecode[24] = 39

	// Turn structure offset = 39 (big-endian at bytes 25-28)
	bytecode[28] = 39

	// Win conditions offset = 43 (big-endian at bytes 29-32)
	bytecode[32] = 43

	// Scoring offset = 48 (big-endian at bytes 33-36)
	bytecode[36] = 48

	// Tableau mode = 1 (WAR)
	bytecode[37] = 1

	// Sequence direction = 0 (ASCENDING)
	bytecode[38] = 0

	// Turn structure section at offset 39: phase_count = 0
	// (4 bytes, all zeros - already zero)

	// Win conditions section at offset 43: count = 0
	// (4 bytes, all zeros - already zero)

	genome, err := ParseGenome(bytecode)
	if err != nil {
		t.Fatalf("ParseGenome failed: %v", err)
	}

	// Check the new fields were parsed
	if genome.Header.BytecodeVersion != 2 {
		t.Errorf("Expected BytecodeVersion 2, got %d", genome.Header.BytecodeVersion)
	}
	if genome.Header.TableauMode != 1 {
		t.Errorf("Expected TableauMode 1, got %d", genome.Header.TableauMode)
	}
	if genome.Header.SequenceDirection != 0 {
		t.Errorf("Expected SequenceDirection 0, got %d", genome.Header.SequenceDirection)
	}

	// Check existing fields still work
	if genome.Header.Version != 1 {
		t.Errorf("Expected Version 1, got %d", genome.Header.Version)
	}
	if genome.Header.PlayerCount != 2 {
		t.Errorf("Expected PlayerCount 2, got %d", genome.Header.PlayerCount)
	}
	if genome.Header.MaxTurns != 100 {
		t.Errorf("Expected MaxTurns 100, got %d", genome.Header.MaxTurns)
	}
}

func TestBytecodeHeaderTeamFields(t *testing.T) {
	// Create minimal bytecode with team fields
	// Header size is 53 bytes for V2 with team fields
	bytecode := make([]byte, 60)
	bytecode[0] = 2  // version = 2 (V2 format)
	bytecode[16] = 4 // num_players = 4 (at byte 13-16 for V2)
	// ... other header fields (set offsets to avoid parse errors) ...
	bytecode[28] = 53 // turn_structure_offset = 53
	bytecode[32] = 57 // win_conditions_offset = 57
	// Bytes 47-52: team fields
	bytecode[47] = 1 // team_mode = true
	bytecode[48] = 2 // team_count = 2
	// team_data_offset = 53 (big-endian)
	bytecode[49] = 0
	bytecode[50] = 0
	bytecode[51] = 0
	bytecode[52] = 53
	// Team data at offset 53
	bytecode[53] = 2 // num_teams
	bytecode[54] = 2 // team 0 size
	bytecode[55] = 0 // team 0 player 0
	bytecode[56] = 2 // team 0 player 2
	bytecode[57] = 2 // team 1 size
	bytecode[58] = 1 // team 1 player 1
	bytecode[59] = 3 // team 1 player 3

	header, err := ParseHeader(bytecode)
	if err != nil {
		t.Fatalf("ParseHeader failed: %v", err)
	}

	if !header.TeamMode {
		t.Error("Expected TeamMode to be true")
	}
	if header.TeamCount != 2 {
		t.Errorf("Expected TeamCount 2, got %d", header.TeamCount)
	}
	if header.TeamDataOffset != 53 {
		t.Errorf("Expected TeamDataOffset 53, got %d", header.TeamDataOffset)
	}
}

func TestParseTeams(t *testing.T) {
	// Team data format: [num_teams][team_size][players...][team_size][players...]
	teamData := []byte{
		2,       // num_teams = 2
		2, 0, 2, // team 0: size=2, players=[0, 2]
		2, 1, 3, // team 1: size=2, players=[1, 3]
	}

	teams := ParseTeams(teamData)

	if len(teams) != 2 {
		t.Fatalf("Expected 2 teams, got %d", len(teams))
	}
	if !reflect.DeepEqual(teams[0], []int{0, 2}) {
		t.Errorf("Team 0 expected [0, 2], got %v", teams[0])
	}
	if !reflect.DeepEqual(teams[1], []int{1, 3}) {
		t.Errorf("Team 1 expected [1, 3], got %v", teams[1])
	}
}

func TestParseTeamsEmpty(t *testing.T) {
	teamData := []byte{0} // num_teams = 0

	teams := ParseTeams(teamData)

	if len(teams) != 0 {
		t.Errorf("Expected 0 teams, got %d", len(teams))
	}
}

func TestBytecodeHeaderNoTeams(t *testing.T) {
	// Header without teams (team_mode = false)
	// Need at least 53 bytes for V2 header with team fields
	bytecode := make([]byte, 60)
	bytecode[0] = 2  // version = 2 (V2 format)
	bytecode[28] = 53 // turn_structure_offset
	bytecode[32] = 57 // win_conditions_offset
	bytecode[47] = 0 // team_mode = false
	bytecode[48] = 0 // team_count = 0

	header, err := ParseHeader(bytecode)
	if err != nil {
		t.Fatalf("ParseHeader failed: %v", err)
	}

	if header.TeamMode {
		t.Error("Expected TeamMode to be false")
	}
	if header.TeamCount != 0 {
		t.Errorf("Expected TeamCount 0, got %d", header.TeamCount)
	}
}

func TestParseTeamsNil(t *testing.T) {
	// Empty byte slice should return nil/empty
	teams := ParseTeams([]byte{})

	if teams != nil {
		t.Errorf("Expected nil for empty data, got %v", teams)
	}
}

func TestParseTeamsSingleTeam(t *testing.T) {
	// Single team with 3 players
	teamData := []byte{
		1,          // num_teams = 1
		3, 0, 1, 2, // team 0: size=3, players=[0, 1, 2]
	}

	teams := ParseTeams(teamData)

	if len(teams) != 1 {
		t.Fatalf("Expected 1 team, got %d", len(teams))
	}
	if !reflect.DeepEqual(teams[0], []int{0, 1, 2}) {
		t.Errorf("Team 0 expected [0, 1, 2], got %v", teams[0])
	}
}
